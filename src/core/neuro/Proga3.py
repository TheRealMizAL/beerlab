import numpy as np

print(
    ' Приветствуем!\nПредставляем Вам нейронную сеть, которая может определить стиль пива по трём параметрам:\nСодержанию алкоголя (ABV), горькости (IBU) и цвету (SRM).\n Убедитесь в этом сами!')
# создаем бесконечный цикл для перезапуска программы
while True:
    # Создаем пустой список для хранения чисел
    x = []
    # Создаем список параметров
    param = ['ABV', 'IBU', 'SRM']
    # Вводим три float числа с клавиатуры через enter
    for i in range(len(param)):
        # Выводим новую фразу перед вводом каждого числа
        print(f'Введи', param[i], ':')
        # Считываем введенное число и преобразуем его в float
        k = float(input())
        # Добавляем число в список
        x.append(k)

    # Инициализируем веса и отклонения случайными значениями из нормального распределения
    W1 = np.array([[-0.40502144, -0.93633326, -0.86327296, -3.18600994],
                   [-0.27372356, -1.21011035, 0.03143406, -0.15104436],
                   [0.34807652, 3.23231823, 4.19038441, 3.43844524]])  # матрица весов между входным и скрытым слоем
    b1 = np.array([-2.56002424, -2.03657545, -10.6214421, 8.63984862])  # вектор отклонений для скрытого слоя
    W2 = np.array([[0.64556229, 0.36903174, 0.08534635, -0.88088607, -0.44449435],
                   [0.10812743, -1.81674948, -0.63352288, 3.31674312, -0.18323783],
                   [1.4011323, 3.68675545, -1.82293961, 0.45710413, -5.51764906],
                   [-1.34669968, -4.03830786, 1.95626767, -0.38171694,
                    5.11665978]])  # матрица весов между скрытым и выходным слоем
    b2 = np.array(
            [3.61178849, -14.29973531, 9.87931404, -3.92753248, -0.42083069])  # вектор отклонений для выходного слоя


    # Определяем функции активации и их производные
    def relu(t):  # функция ReLu
        return np.maximum(t, 0)  # возвращает максимум между 0 и x


    def softmax(t):  # функция softmax
        out = np.exp(t)  # вычитаем максимум по строкам для численной стабилизации
        return out / np.sum(out)  # делим на сумму по строкам


    def predict(x):
        h1 = x @ W1 + b1  # линейная комбинация входов и весов для скрытого слоя
        t1 = relu(h1)  # активация скрытого слоя функцией ReLu
        h2 = t1 @ W2 + b2  # линейная комбинация скрытых нейронов и весов для выходного слоя
        z = softmax(h2)  # активация выходного слоя функцией softmax
        return z  # вывод выходных параметров


    probs = predict(x)
    pred_class = np.argmax(probs)
    class_names = ['APA', 'IPA', 'Lager', 'Stout/Porter', 'Gose']
    print('Предполагаемый стиль:', "\033[3;33m", class_names[pred_class], "\033[0m",
          '\nЖелаете определить еще раз? \n  0 - нет\n  1 - да')
    g = int(input())
    if g == 0: break
print('Были рады помочь! \n made by \033[1;35m K2GO\033[0m')
